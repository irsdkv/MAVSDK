// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: logging/logging.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_logging_2flogging_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_logging_2flogging_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_logging_2flogging_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_logging_2flogging_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_logging_2flogging_2eproto;
namespace mavsdk {
namespace rpc {
namespace logging {
class LoggingRaw;
class LoggingRawDefaultTypeInternal;
extern LoggingRawDefaultTypeInternal _LoggingRaw_default_instance_;
class LoggingRawResponse;
class LoggingRawResponseDefaultTypeInternal;
extern LoggingRawResponseDefaultTypeInternal _LoggingRawResponse_default_instance_;
class LoggingResult;
class LoggingResultDefaultTypeInternal;
extern LoggingResultDefaultTypeInternal _LoggingResult_default_instance_;
class StartLoggingRequest;
class StartLoggingRequestDefaultTypeInternal;
extern StartLoggingRequestDefaultTypeInternal _StartLoggingRequest_default_instance_;
class StartLoggingResponse;
class StartLoggingResponseDefaultTypeInternal;
extern StartLoggingResponseDefaultTypeInternal _StartLoggingResponse_default_instance_;
class StopLoggingRequest;
class StopLoggingRequestDefaultTypeInternal;
extern StopLoggingRequestDefaultTypeInternal _StopLoggingRequest_default_instance_;
class StopLoggingResponse;
class StopLoggingResponseDefaultTypeInternal;
extern StopLoggingResponseDefaultTypeInternal _StopLoggingResponse_default_instance_;
class SubscribeLoggingRawRequest;
class SubscribeLoggingRawRequestDefaultTypeInternal;
extern SubscribeLoggingRawRequestDefaultTypeInternal _SubscribeLoggingRawRequest_default_instance_;
}  // namespace logging
}  // namespace rpc
}  // namespace mavsdk
PROTOBUF_NAMESPACE_OPEN
template<> ::mavsdk::rpc::logging::LoggingRaw* Arena::CreateMaybeMessage<::mavsdk::rpc::logging::LoggingRaw>(Arena*);
template<> ::mavsdk::rpc::logging::LoggingRawResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::logging::LoggingRawResponse>(Arena*);
template<> ::mavsdk::rpc::logging::LoggingResult* Arena::CreateMaybeMessage<::mavsdk::rpc::logging::LoggingResult>(Arena*);
template<> ::mavsdk::rpc::logging::StartLoggingRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::logging::StartLoggingRequest>(Arena*);
template<> ::mavsdk::rpc::logging::StartLoggingResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::logging::StartLoggingResponse>(Arena*);
template<> ::mavsdk::rpc::logging::StopLoggingRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::logging::StopLoggingRequest>(Arena*);
template<> ::mavsdk::rpc::logging::StopLoggingResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::logging::StopLoggingResponse>(Arena*);
template<> ::mavsdk::rpc::logging::SubscribeLoggingRawRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::logging::SubscribeLoggingRawRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mavsdk {
namespace rpc {
namespace logging {

enum LoggingResult_Result : int {
  LoggingResult_Result_SUCCESS = 0,
  LoggingResult_Result_NO_SYSTEM = 1,
  LoggingResult_Result_CONNECTION_ERROR = 2,
  LoggingResult_Result_BUSY = 3,
  LoggingResult_Result_COMMAND_DENIED = 4,
  LoggingResult_Result_TIMEOUT = 5,
  LoggingResult_Result_UNKNOWN = 6,
  LoggingResult_Result_LoggingResult_Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LoggingResult_Result_LoggingResult_Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LoggingResult_Result_IsValid(int value);
constexpr LoggingResult_Result LoggingResult_Result_Result_MIN = LoggingResult_Result_SUCCESS;
constexpr LoggingResult_Result LoggingResult_Result_Result_MAX = LoggingResult_Result_UNKNOWN;
constexpr int LoggingResult_Result_Result_ARRAYSIZE = LoggingResult_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoggingResult_Result_descriptor();
template<typename T>
inline const std::string& LoggingResult_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoggingResult_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoggingResult_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoggingResult_Result_descriptor(), enum_t_value);
}
inline bool LoggingResult_Result_Parse(
    const std::string& name, LoggingResult_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoggingResult_Result>(
    LoggingResult_Result_descriptor(), name, value);
}
// ===================================================================

class StartLoggingRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.logging.StartLoggingRequest) */ {
 public:
  StartLoggingRequest();
  virtual ~StartLoggingRequest();

  StartLoggingRequest(const StartLoggingRequest& from);
  StartLoggingRequest(StartLoggingRequest&& from) noexcept
    : StartLoggingRequest() {
    *this = ::std::move(from);
  }

  inline StartLoggingRequest& operator=(const StartLoggingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartLoggingRequest& operator=(StartLoggingRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StartLoggingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartLoggingRequest* internal_default_instance() {
    return reinterpret_cast<const StartLoggingRequest*>(
               &_StartLoggingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StartLoggingRequest& a, StartLoggingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartLoggingRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartLoggingRequest* New() const final {
    return CreateMaybeMessage<StartLoggingRequest>(nullptr);
  }

  StartLoggingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartLoggingRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StartLoggingRequest& from);
  void MergeFrom(const StartLoggingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartLoggingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.logging.StartLoggingRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logging_2flogging_2eproto);
    return ::descriptor_table_logging_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.logging.StartLoggingRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logging_2flogging_2eproto;
};
// -------------------------------------------------------------------

class StartLoggingResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.logging.StartLoggingResponse) */ {
 public:
  StartLoggingResponse();
  virtual ~StartLoggingResponse();

  StartLoggingResponse(const StartLoggingResponse& from);
  StartLoggingResponse(StartLoggingResponse&& from) noexcept
    : StartLoggingResponse() {
    *this = ::std::move(from);
  }

  inline StartLoggingResponse& operator=(const StartLoggingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartLoggingResponse& operator=(StartLoggingResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StartLoggingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartLoggingResponse* internal_default_instance() {
    return reinterpret_cast<const StartLoggingResponse*>(
               &_StartLoggingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StartLoggingResponse& a, StartLoggingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartLoggingResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartLoggingResponse* New() const final {
    return CreateMaybeMessage<StartLoggingResponse>(nullptr);
  }

  StartLoggingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartLoggingResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StartLoggingResponse& from);
  void MergeFrom(const StartLoggingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartLoggingResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.logging.StartLoggingResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logging_2flogging_2eproto);
    return ::descriptor_table_logging_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoggingResultFieldNumber = 1,
  };
  // .mavsdk.rpc.logging.LoggingResult logging_result = 1;
  bool has_logging_result() const;
  private:
  bool _internal_has_logging_result() const;
  public:
  void clear_logging_result();
  const ::mavsdk::rpc::logging::LoggingResult& logging_result() const;
  ::mavsdk::rpc::logging::LoggingResult* release_logging_result();
  ::mavsdk::rpc::logging::LoggingResult* mutable_logging_result();
  void set_allocated_logging_result(::mavsdk::rpc::logging::LoggingResult* logging_result);

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.logging.StartLoggingResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::mavsdk::rpc::logging::LoggingResult* logging_result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logging_2flogging_2eproto;
};
// -------------------------------------------------------------------

class StopLoggingRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.logging.StopLoggingRequest) */ {
 public:
  StopLoggingRequest();
  virtual ~StopLoggingRequest();

  StopLoggingRequest(const StopLoggingRequest& from);
  StopLoggingRequest(StopLoggingRequest&& from) noexcept
    : StopLoggingRequest() {
    *this = ::std::move(from);
  }

  inline StopLoggingRequest& operator=(const StopLoggingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopLoggingRequest& operator=(StopLoggingRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopLoggingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopLoggingRequest* internal_default_instance() {
    return reinterpret_cast<const StopLoggingRequest*>(
               &_StopLoggingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StopLoggingRequest& a, StopLoggingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopLoggingRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopLoggingRequest* New() const final {
    return CreateMaybeMessage<StopLoggingRequest>(nullptr);
  }

  StopLoggingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopLoggingRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopLoggingRequest& from);
  void MergeFrom(const StopLoggingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopLoggingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.logging.StopLoggingRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logging_2flogging_2eproto);
    return ::descriptor_table_logging_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.logging.StopLoggingRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logging_2flogging_2eproto;
};
// -------------------------------------------------------------------

class StopLoggingResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.logging.StopLoggingResponse) */ {
 public:
  StopLoggingResponse();
  virtual ~StopLoggingResponse();

  StopLoggingResponse(const StopLoggingResponse& from);
  StopLoggingResponse(StopLoggingResponse&& from) noexcept
    : StopLoggingResponse() {
    *this = ::std::move(from);
  }

  inline StopLoggingResponse& operator=(const StopLoggingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopLoggingResponse& operator=(StopLoggingResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopLoggingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopLoggingResponse* internal_default_instance() {
    return reinterpret_cast<const StopLoggingResponse*>(
               &_StopLoggingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StopLoggingResponse& a, StopLoggingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopLoggingResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopLoggingResponse* New() const final {
    return CreateMaybeMessage<StopLoggingResponse>(nullptr);
  }

  StopLoggingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopLoggingResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopLoggingResponse& from);
  void MergeFrom(const StopLoggingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopLoggingResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.logging.StopLoggingResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logging_2flogging_2eproto);
    return ::descriptor_table_logging_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoggingResultFieldNumber = 1,
  };
  // .mavsdk.rpc.logging.LoggingResult logging_result = 1;
  bool has_logging_result() const;
  private:
  bool _internal_has_logging_result() const;
  public:
  void clear_logging_result();
  const ::mavsdk::rpc::logging::LoggingResult& logging_result() const;
  ::mavsdk::rpc::logging::LoggingResult* release_logging_result();
  ::mavsdk::rpc::logging::LoggingResult* mutable_logging_result();
  void set_allocated_logging_result(::mavsdk::rpc::logging::LoggingResult* logging_result);

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.logging.StopLoggingResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::mavsdk::rpc::logging::LoggingResult* logging_result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logging_2flogging_2eproto;
};
// -------------------------------------------------------------------

class SubscribeLoggingRawRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.logging.SubscribeLoggingRawRequest) */ {
 public:
  SubscribeLoggingRawRequest();
  virtual ~SubscribeLoggingRawRequest();

  SubscribeLoggingRawRequest(const SubscribeLoggingRawRequest& from);
  SubscribeLoggingRawRequest(SubscribeLoggingRawRequest&& from) noexcept
    : SubscribeLoggingRawRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeLoggingRawRequest& operator=(const SubscribeLoggingRawRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeLoggingRawRequest& operator=(SubscribeLoggingRawRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubscribeLoggingRawRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscribeLoggingRawRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeLoggingRawRequest*>(
               &_SubscribeLoggingRawRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SubscribeLoggingRawRequest& a, SubscribeLoggingRawRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeLoggingRawRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubscribeLoggingRawRequest* New() const final {
    return CreateMaybeMessage<SubscribeLoggingRawRequest>(nullptr);
  }

  SubscribeLoggingRawRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubscribeLoggingRawRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubscribeLoggingRawRequest& from);
  void MergeFrom(const SubscribeLoggingRawRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeLoggingRawRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.logging.SubscribeLoggingRawRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logging_2flogging_2eproto);
    return ::descriptor_table_logging_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.logging.SubscribeLoggingRawRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logging_2flogging_2eproto;
};
// -------------------------------------------------------------------

class LoggingRawResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.logging.LoggingRawResponse) */ {
 public:
  LoggingRawResponse();
  virtual ~LoggingRawResponse();

  LoggingRawResponse(const LoggingRawResponse& from);
  LoggingRawResponse(LoggingRawResponse&& from) noexcept
    : LoggingRawResponse() {
    *this = ::std::move(from);
  }

  inline LoggingRawResponse& operator=(const LoggingRawResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoggingRawResponse& operator=(LoggingRawResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoggingRawResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoggingRawResponse* internal_default_instance() {
    return reinterpret_cast<const LoggingRawResponse*>(
               &_LoggingRawResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoggingRawResponse& a, LoggingRawResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoggingRawResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoggingRawResponse* New() const final {
    return CreateMaybeMessage<LoggingRawResponse>(nullptr);
  }

  LoggingRawResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoggingRawResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoggingRawResponse& from);
  void MergeFrom(const LoggingRawResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoggingRawResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.logging.LoggingRawResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logging_2flogging_2eproto);
    return ::descriptor_table_logging_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoggingRawFieldNumber = 1,
  };
  // .mavsdk.rpc.logging.LoggingRaw logging_raw = 1;
  bool has_logging_raw() const;
  private:
  bool _internal_has_logging_raw() const;
  public:
  void clear_logging_raw();
  const ::mavsdk::rpc::logging::LoggingRaw& logging_raw() const;
  ::mavsdk::rpc::logging::LoggingRaw* release_logging_raw();
  ::mavsdk::rpc::logging::LoggingRaw* mutable_logging_raw();
  void set_allocated_logging_raw(::mavsdk::rpc::logging::LoggingRaw* logging_raw);

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.logging.LoggingRawResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::mavsdk::rpc::logging::LoggingRaw* logging_raw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logging_2flogging_2eproto;
};
// -------------------------------------------------------------------

class LoggingRaw :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.logging.LoggingRaw) */ {
 public:
  LoggingRaw();
  virtual ~LoggingRaw();

  LoggingRaw(const LoggingRaw& from);
  LoggingRaw(LoggingRaw&& from) noexcept
    : LoggingRaw() {
    *this = ::std::move(from);
  }

  inline LoggingRaw& operator=(const LoggingRaw& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoggingRaw& operator=(LoggingRaw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoggingRaw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoggingRaw* internal_default_instance() {
    return reinterpret_cast<const LoggingRaw*>(
               &_LoggingRaw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoggingRaw& a, LoggingRaw& b) {
    a.Swap(&b);
  }
  inline void Swap(LoggingRaw* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoggingRaw* New() const final {
    return CreateMaybeMessage<LoggingRaw>(nullptr);
  }

  LoggingRaw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoggingRaw>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoggingRaw& from);
  void MergeFrom(const LoggingRaw& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoggingRaw* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.logging.LoggingRaw";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logging_2flogging_2eproto);
    return ::descriptor_table_logging_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kFirstMessageOffsetFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint32 first_message_offset = 1;
  void clear_first_message_offset();
  ::PROTOBUF_NAMESPACE_ID::uint32 first_message_offset() const;
  void set_first_message_offset(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.logging.LoggingRaw)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 first_message_offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logging_2flogging_2eproto;
};
// -------------------------------------------------------------------

class LoggingResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.logging.LoggingResult) */ {
 public:
  LoggingResult();
  virtual ~LoggingResult();

  LoggingResult(const LoggingResult& from);
  LoggingResult(LoggingResult&& from) noexcept
    : LoggingResult() {
    *this = ::std::move(from);
  }

  inline LoggingResult& operator=(const LoggingResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoggingResult& operator=(LoggingResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoggingResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoggingResult* internal_default_instance() {
    return reinterpret_cast<const LoggingResult*>(
               &_LoggingResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LoggingResult& a, LoggingResult& b) {
    a.Swap(&b);
  }
  inline void Swap(LoggingResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoggingResult* New() const final {
    return CreateMaybeMessage<LoggingResult>(nullptr);
  }

  LoggingResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoggingResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoggingResult& from);
  void MergeFrom(const LoggingResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoggingResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.logging.LoggingResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logging_2flogging_2eproto);
    return ::descriptor_table_logging_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LoggingResult_Result Result;
  static constexpr Result SUCCESS =
    LoggingResult_Result_SUCCESS;
  static constexpr Result NO_SYSTEM =
    LoggingResult_Result_NO_SYSTEM;
  static constexpr Result CONNECTION_ERROR =
    LoggingResult_Result_CONNECTION_ERROR;
  static constexpr Result BUSY =
    LoggingResult_Result_BUSY;
  static constexpr Result COMMAND_DENIED =
    LoggingResult_Result_COMMAND_DENIED;
  static constexpr Result TIMEOUT =
    LoggingResult_Result_TIMEOUT;
  static constexpr Result UNKNOWN =
    LoggingResult_Result_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return LoggingResult_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    LoggingResult_Result_Result_MIN;
  static constexpr Result Result_MAX =
    LoggingResult_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    LoggingResult_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return LoggingResult_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return LoggingResult_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(const std::string& name,
      Result* value) {
    return LoggingResult_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultStrFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // string result_str = 2;
  void clear_result_str();
  const std::string& result_str() const;
  void set_result_str(const std::string& value);
  void set_result_str(std::string&& value);
  void set_result_str(const char* value);
  void set_result_str(const char* value, size_t size);
  std::string* mutable_result_str();
  std::string* release_result_str();
  void set_allocated_result_str(std::string* result_str);
  private:
  const std::string& _internal_result_str() const;
  void _internal_set_result_str(const std::string& value);
  std::string* _internal_mutable_result_str();
  public:

  // .mavsdk.rpc.logging.LoggingResult.Result result = 1;
  void clear_result();
  ::mavsdk::rpc::logging::LoggingResult_Result result() const;
  void set_result(::mavsdk::rpc::logging::LoggingResult_Result value);

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.logging.LoggingResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_str_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logging_2flogging_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StartLoggingRequest

// -------------------------------------------------------------------

// StartLoggingResponse

// .mavsdk.rpc.logging.LoggingResult logging_result = 1;
inline bool StartLoggingResponse::has_logging_result() const {
  return this != internal_default_instance() && logging_result_ != nullptr;
}
inline void StartLoggingResponse::clear_logging_result() {
  if (GetArenaNoVirtual() == nullptr && logging_result_ != nullptr) {
    delete logging_result_;
  }
  logging_result_ = nullptr;
}
inline const ::mavsdk::rpc::logging::LoggingResult& StartLoggingResponse::logging_result() const {
  const ::mavsdk::rpc::logging::LoggingResult* p = logging_result_;
  // @@protoc_insertion_point(field_get:mavsdk.rpc.logging.StartLoggingResponse.logging_result)
  return p != nullptr ? *p : *reinterpret_cast<const ::mavsdk::rpc::logging::LoggingResult*>(
      &::mavsdk::rpc::logging::_LoggingResult_default_instance_);
}
inline ::mavsdk::rpc::logging::LoggingResult* StartLoggingResponse::release_logging_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.logging.StartLoggingResponse.logging_result)
  
  ::mavsdk::rpc::logging::LoggingResult* temp = logging_result_;
  logging_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::logging::LoggingResult* StartLoggingResponse::mutable_logging_result() {
  
  if (logging_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::logging::LoggingResult>(GetArenaNoVirtual());
    logging_result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.logging.StartLoggingResponse.logging_result)
  return logging_result_;
}
inline void StartLoggingResponse::set_allocated_logging_result(::mavsdk::rpc::logging::LoggingResult* logging_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete logging_result_;
  }
  if (logging_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logging_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logging_result, submessage_arena);
    }
    
  } else {
    
  }
  logging_result_ = logging_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.logging.StartLoggingResponse.logging_result)
}

// -------------------------------------------------------------------

// StopLoggingRequest

// -------------------------------------------------------------------

// StopLoggingResponse

// .mavsdk.rpc.logging.LoggingResult logging_result = 1;
inline bool StopLoggingResponse::has_logging_result() const {
  return this != internal_default_instance() && logging_result_ != nullptr;
}
inline void StopLoggingResponse::clear_logging_result() {
  if (GetArenaNoVirtual() == nullptr && logging_result_ != nullptr) {
    delete logging_result_;
  }
  logging_result_ = nullptr;
}
inline const ::mavsdk::rpc::logging::LoggingResult& StopLoggingResponse::logging_result() const {
  const ::mavsdk::rpc::logging::LoggingResult* p = logging_result_;
  // @@protoc_insertion_point(field_get:mavsdk.rpc.logging.StopLoggingResponse.logging_result)
  return p != nullptr ? *p : *reinterpret_cast<const ::mavsdk::rpc::logging::LoggingResult*>(
      &::mavsdk::rpc::logging::_LoggingResult_default_instance_);
}
inline ::mavsdk::rpc::logging::LoggingResult* StopLoggingResponse::release_logging_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.logging.StopLoggingResponse.logging_result)
  
  ::mavsdk::rpc::logging::LoggingResult* temp = logging_result_;
  logging_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::logging::LoggingResult* StopLoggingResponse::mutable_logging_result() {
  
  if (logging_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::logging::LoggingResult>(GetArenaNoVirtual());
    logging_result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.logging.StopLoggingResponse.logging_result)
  return logging_result_;
}
inline void StopLoggingResponse::set_allocated_logging_result(::mavsdk::rpc::logging::LoggingResult* logging_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete logging_result_;
  }
  if (logging_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logging_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logging_result, submessage_arena);
    }
    
  } else {
    
  }
  logging_result_ = logging_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.logging.StopLoggingResponse.logging_result)
}

// -------------------------------------------------------------------

// SubscribeLoggingRawRequest

// -------------------------------------------------------------------

// LoggingRawResponse

// .mavsdk.rpc.logging.LoggingRaw logging_raw = 1;
inline bool LoggingRawResponse::has_logging_raw() const {
  return this != internal_default_instance() && logging_raw_ != nullptr;
}
inline void LoggingRawResponse::clear_logging_raw() {
  if (GetArenaNoVirtual() == nullptr && logging_raw_ != nullptr) {
    delete logging_raw_;
  }
  logging_raw_ = nullptr;
}
inline const ::mavsdk::rpc::logging::LoggingRaw& LoggingRawResponse::logging_raw() const {
  const ::mavsdk::rpc::logging::LoggingRaw* p = logging_raw_;
  // @@protoc_insertion_point(field_get:mavsdk.rpc.logging.LoggingRawResponse.logging_raw)
  return p != nullptr ? *p : *reinterpret_cast<const ::mavsdk::rpc::logging::LoggingRaw*>(
      &::mavsdk::rpc::logging::_LoggingRaw_default_instance_);
}
inline ::mavsdk::rpc::logging::LoggingRaw* LoggingRawResponse::release_logging_raw() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.logging.LoggingRawResponse.logging_raw)
  
  ::mavsdk::rpc::logging::LoggingRaw* temp = logging_raw_;
  logging_raw_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::logging::LoggingRaw* LoggingRawResponse::mutable_logging_raw() {
  
  if (logging_raw_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::logging::LoggingRaw>(GetArenaNoVirtual());
    logging_raw_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.logging.LoggingRawResponse.logging_raw)
  return logging_raw_;
}
inline void LoggingRawResponse::set_allocated_logging_raw(::mavsdk::rpc::logging::LoggingRaw* logging_raw) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete logging_raw_;
  }
  if (logging_raw) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logging_raw = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logging_raw, submessage_arena);
    }
    
  } else {
    
  }
  logging_raw_ = logging_raw;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.logging.LoggingRawResponse.logging_raw)
}

// -------------------------------------------------------------------

// LoggingRaw

// uint32 first_message_offset = 1;
inline void LoggingRaw::clear_first_message_offset() {
  first_message_offset_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LoggingRaw::first_message_offset() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.logging.LoggingRaw.first_message_offset)
  return first_message_offset_;
}
inline void LoggingRaw::set_first_message_offset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  first_message_offset_ = value;
  // @@protoc_insertion_point(field_set:mavsdk.rpc.logging.LoggingRaw.first_message_offset)
}

// bytes data = 2;
inline void LoggingRaw::clear_data() {
  data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoggingRaw::data() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.logging.LoggingRaw.data)
  return _internal_data();
}
inline void LoggingRaw::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.logging.LoggingRaw.data)
}
inline std::string* LoggingRaw::mutable_data() {
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.logging.LoggingRaw.data)
  return _internal_mutable_data();
}
inline const std::string& LoggingRaw::_internal_data() const {
  return data_.GetNoArena();
}
inline void LoggingRaw::_internal_set_data(const std::string& value) {
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LoggingRaw::set_data(std::string&& value) {
  
  data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mavsdk.rpc.logging.LoggingRaw.data)
}
inline void LoggingRaw::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mavsdk.rpc.logging.LoggingRaw.data)
}
inline void LoggingRaw::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mavsdk.rpc.logging.LoggingRaw.data)
}
inline std::string* LoggingRaw::_internal_mutable_data() {
  
  return data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoggingRaw::release_data() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.logging.LoggingRaw.data)
  
  return data_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoggingRaw::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.logging.LoggingRaw.data)
}

// -------------------------------------------------------------------

// LoggingResult

// .mavsdk.rpc.logging.LoggingResult.Result result = 1;
inline void LoggingResult::clear_result() {
  result_ = 0;
}
inline ::mavsdk::rpc::logging::LoggingResult_Result LoggingResult::result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.logging.LoggingResult.result)
  return static_cast< ::mavsdk::rpc::logging::LoggingResult_Result >(result_);
}
inline void LoggingResult::set_result(::mavsdk::rpc::logging::LoggingResult_Result value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:mavsdk.rpc.logging.LoggingResult.result)
}

// string result_str = 2;
inline void LoggingResult::clear_result_str() {
  result_str_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoggingResult::result_str() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.logging.LoggingResult.result_str)
  return _internal_result_str();
}
inline void LoggingResult::set_result_str(const std::string& value) {
  _internal_set_result_str(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.logging.LoggingResult.result_str)
}
inline std::string* LoggingResult::mutable_result_str() {
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.logging.LoggingResult.result_str)
  return _internal_mutable_result_str();
}
inline const std::string& LoggingResult::_internal_result_str() const {
  return result_str_.GetNoArena();
}
inline void LoggingResult::_internal_set_result_str(const std::string& value) {
  
  result_str_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LoggingResult::set_result_str(std::string&& value) {
  
  result_str_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mavsdk.rpc.logging.LoggingResult.result_str)
}
inline void LoggingResult::set_result_str(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  result_str_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mavsdk.rpc.logging.LoggingResult.result_str)
}
inline void LoggingResult::set_result_str(const char* value, size_t size) {
  
  result_str_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mavsdk.rpc.logging.LoggingResult.result_str)
}
inline std::string* LoggingResult::_internal_mutable_result_str() {
  
  return result_str_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoggingResult::release_result_str() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.logging.LoggingResult.result_str)
  
  return result_str_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoggingResult::set_allocated_result_str(std::string* result_str) {
  if (result_str != nullptr) {
    
  } else {
    
  }
  result_str_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result_str);
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.logging.LoggingResult.result_str)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace logging
}  // namespace rpc
}  // namespace mavsdk

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mavsdk::rpc::logging::LoggingResult_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mavsdk::rpc::logging::LoggingResult_Result>() {
  return ::mavsdk::rpc::logging::LoggingResult_Result_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_logging_2flogging_2eproto
